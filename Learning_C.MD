// C언어 공부 기록

// C언어 입문계기.
// GPT를 통해 평소 세계관 구축, 철학적 잡담을 주로 나누던 중 어쩌다보니 C언어의 대한 이야기를 나누게 됨.
// 그때 C언어의 대한 개념을 이해함.
// C언어란 조립되지 않은 레고블럭같은 것.
// 파이썬 자바등 다른 언어들과 다른 점은 같은 레고블럭을 사용하지만 C언어는 2칸짜리 가장 기본모양의 레고블럭으로 무한한 가능성을 만들어낼 수 있는 언어이고
// 파이썬 자바등은 2칸짜리 레고블럭이아닌 3칸짜리 레고블럭, ㄴ자 레고블럭, ㅁ자 레고블럭 ㅇ자 레고블럭등 최소한의 블럭으로 여러가지를 만들어 낼 수 있는 언어라고 이해함.
// 결국 컴퓨터 언어를 이용해 무언가를 만들어낸다는 본질은 같지만 모든걸 내가 직접 만드느냐, 사람들이 많이 사용하는 부분들을 사전에 정의 해두어서 좀 더 편하게 만드느냐의 차이가 있다는 것을 알게 됨.

// 수 많은 날이 지나고 게임을 하다 우연히 디스코드 채널의 템플릿을 보게 되었고 템플릿만 달랑 있는게 아쉬워서 봇을 한번 넣어볼까? 생각해
// GPT를 통해 파이썬으로 디스코드 뮤직봇을 만들고 적용까지 성공함.
// 그 과정에서 내용은 모르겠지만 옆에 주석으로 표시된 부분을 통해 아.. 이런 구조를 가지고 있구나를 추론해보고 그 코드를 자연어로 분해하는 과정에서 와 이거 재밌다를 생각함.
// 근데 여기서 파이썬을 배우지 않고 C언어를 택한건 내가 직업적으로 개발을 하지 않는데 굳이 파이썬을 깊게 배워야 할까?
// 일상생활에서 파이썬을 이용하면 편안한 상황이 많지만 필요한 것들은 대부분 그다지 복잡한 것들이 아니기에 이런건 AI를 통해 구현하고 나는 본질의 대해서 좀 더 알아가고자 생각해가지고 C언어를 택함.

// 그리고 여기서부터 C언어의 대해서 배우기 시작. 최초로는 아래 코드를 번역해 나가는 과정부터 시작했음

#include <stdio.h> // stdio.h는 헤더인데 자연어로는 도구가 들어있는 도구함이라고 생각하면 되는 것, printf라는 도구를 사용하기 위해 printf가 들어있는 stdio라는 헤더의 도구함을 include라는 명령을 통해 가져온 것.

int main(){ // main이라는 영역을 {} 안에 펼친 것. 이 안에서 main이 무슨 일을 해야하는지 구현시켜야 함.
printf("hello world"); 
// printf는 출력을 명령하는 것, 괄호 안에 있는 내용들을 출력해! 라는 명령.
// 괄호안에는 어떤 방식으로 출력해야 하는지 큰따옴표 콤마등으로 구분해서 나에게 알려줘! 라는 의미.
// ; 세미콜론은 문장의 마침표같은 역할.

return 0; 
// 정상종료 신호, 본래 return은 여러 방식으로 사용하며 단순히 정상종료로만 알기에는 많은 일을 하고있지만 아직까지는 이정도로만 이해하고 사용하기로 함.
// return 값을 이해하지 않았다고 사용하지 않아버리면 코드를 완성시킬 수 없기에 우선 그냥 사용하기로 결정함. 후에 return이 정확히 무슨일을 하는지 이해되면 return 1; 과 같은 0이 아닌 다른 값을 넣어 예제로 구현해볼 예정
}

// 위 코드를 하나하나 자연어로 번역해나가며 해당 코드가 무슨 역할을 하는지 파악한 뒤 직접 저 코드를 이해해가면서 사용하기 시작.
// 본래 c언어란 무엇이고 목적은 무엇이며등등을 배운 다음 저 코드를 가장 처음 배운다고 하는데
// 나는 기존에 c언어가 무엇인지 어느정도는 감을 잡아둔 상태이기에 바로 코딩 예제로 넘어간 것.

// 아무튼 예제를 자연어로 번역해나가면서 AI에게 내가 생각한 것이 맞는지 계속 되물어보면서 교정의 과정을 거치기 시작함.
// 위 내용은 2025. 12. 12 까지의 기록

// 기초에서 배운 int는 정수를 정의할때 사용하는 것.
// 물론 다른 의미로 사용도 가능하지만 나는 아직까지 int를 main의 영역을 열고 닫을때와 정수 값을 정의할때 주로 사용함.
// char은 문자를 정의하는 것으로 배웠고 []를 통해 문자열을 사용할 수 있다는 것을 알게됨.
// 문자는 작은따옴표로 구분하고 문자열은 큰따옴표를 구분해야 하는 것도 배움.

// if를 배우며 조건이라는 것을 배움.
// >, <, ==, >=, <=, != 기호 사용법과 else if, else를 어떻게 사용해야 하는지 배웠으나
// 아직까지 간단한 정도로만 구현이 가능하고 if안에 if안에 if안에 같이 복잡해지는 구조도 사용할 수 있어야 하지만
// 익숙하지 않아서 사용하지 못하고있음. 이부분은 차근차근 예제들을 만들어가면서 익숙해질예정.

// scanf의 대해서 배웠으나 아직까진 정수를 호출하는 것 밖에 모르겠음

// int a;
// scanf("%d", &a);

// 딱 위 정도로만 사용가능하며 if(scanf(printf(if 등등 막 복잡하게는 아직까찌 사용이 어려움

// CUTECATCAFE 예제는 이렇게 배운 내용들을 기초로 어떻게하면 내가 배운것들을 잘 버무려서 하나의 코드로 만들어볼 수 있을까?
// 라고 생각하면서 만든 구조이며 MSVS에서 코드 타이핑 후 GPT를 통해 빌드 시뮬레이션을 돌리면서 세미콜론이나 큰따옴표등 오타나 실수들을 커버한 뒤
// MSVS에서 직접 빌드까지 해본 후 정상작동이 되는 것을 확인한 뒤 깃허브에 업로드 한 것.

// GPT에게 검증받다보면 내가 알고있는 개념의 대해서 확장이 가능해지는데
// 그 개념의 대해서는 대부분 받아들이면서 내 코드에 직접 사용함.
// 그러나 아직 내가 배우지 않았거나 왜 이렇게 되는지 이해되지 않는 코드들은 절대로 사용하지 않았음.

// GPT는 같은 내용으로 구현할때 char* 나 int main(void) void사용등 내가 본적은 있지만 왜 사용되는지 이해 못하는 코드들을 사용하는데
// 이런 것들은 절대로 사용하지 않았음.
// 2025. 12. 12 ~ 2025. 12. 14 기록

// 소설책을 읽고싶은데 C언어로 코드 짜는게 너무 재미있어서 책읽기를 못하구있다....
// 오늘은 C 안하구 책이나 읽어야지! 하구 침대에 누웠는데 책 한두페이지 읽다가 근데 뭔가 if(){if().... 가 될 것 같은데..
// 한번 해볼까?? 하고 다시 컴퓨터에 앉아서 gpt랑 대화하면서 하나씩 코드짜보는데 된다...ㅠ

// 그래서 spaceship launch checklist 에서 if안에 if를 처음으로 직접 지피티 도움 없이 넣어봤다.
// 그런데 코드를 전부 완성 해놓고 음..? 근데 모든 조건이 안맞으면 별도의 메세지가 출력이 안되던데..
// 출력을 해줘야겠지?? 하면서 다시 if(이거와 저거 하나라도 참이 아닐때...) 로 시작했는데
// gpt가 너의 if가 아직 끊어지지 않았기때문에 그건 if가 아니라 else로 마무리 해야 한다고 조언해주었다.

// 그래서 다시한번 내 코드를 보면서 잠깐 생각을 했더니 if if else return으로 코드가 끝났다..
// 진짜 그러네?? 근데 어떤 대괄호 뒤에 else를 붙여야 되더라... 하면서 한참을 살폈는데 if가 중첩되니까 너무 해깔려서
// 다시 한참동안 생각했다.. ㅠ 그러다가 그냥 여기에다 해볼까? 하고 else{ printf(.......)로 하니까 정상 빌드가 되서 소리질렀다....

// 여기까지 딱 1시간 걸렸음... 아무튼 이제 if를 중첩해서 사용해봤기때문에 아직 중첩된 구조는 한번에 눈에 들어오지 않아서 당분간은 구조가 눈에 익을때까지
// 비슷한 예제를 만들어 볼 예정.

// 그리고 기존에 값이 다른 정수들을 각각의 변수명으로 정의했었는데
// gpt에게 값은 다르지만 같은 의미를 지닌 변수는 int price[3] = {1000,2000,3000}; 처럼 정의 할 수 있고
// 호출은 price[0] 부터 순서대로 [1] [2] 로 호출할 수 있다는 것을 배웠다..

// 이제 의미는 같지만 값이 다른 변수의 대해서 좀 더 간략하게 코드를 만들 수 있을 것 같아서 기분이 너무너무 좋다!
// 2025. 12. 15 ~ 2025. 12. 16 기록

// struct와 for를 배웠다.
// struct는 이해가 쉬웠던게 기존에 하나하나 정의하기 귀찮은데 한번에 할 수 있으면 편하겠다... 라고 생각했었는데
// 마침 의미는 같지만 값이 다른 정의의 대해서 한번에 묶어서 정의할 수 있게 해주는 코드를 보자마자 바로 이해해버렸다.
// 문법이 복잡한 것도 없었고 그저 struct로 내가 원하는 의미의 템플릿을 먼저 만들어 놓고 후에 템플릿을 이용해서 정의하기만 하면 되는 거구나.. 하고
// 근데 단점은 호출할때 변수명이 너무 길어져서 타이핑 하는게 힘들다.. 진짜 간단한거면 괜찮은데 템플릿 이름도 길고 안에 변수명도 길어지면
// 호출할때 aaaaaaaaaa.bbbbbbbb 이렇게 호출해야 되는 경우도 생기니까...
// 그것 빼고는 너무 좋은 것 같다... 아직 이걸로 예제를 만들어보지는 않았는데 아이디어가 떠오른다면 바로 만들어볼 예정.

// for를 배웠지만 아직 정확히 어떻게 써야될지 감은 안잡힌다...
// for(int a = 0; a >= 10; a++)
// 분명 배웠는데 이해될때까지 배우지 않고 그날 학습을 종료했더니
// 다시 까먹어버려서 자연어로 번역이 불가능해졌다...
// 이 부분은 다시 배워야하겠지만 아직 당장은 잘 모르겠다..ㅠ

// 그간 예제를 만들지 않은 이유는 코드를 작성함에있어 세미콜론이나 큰따옴표 콤마, pirntf sncaf등 처럼 단순오타를 제외한 문법실수들이 너무 많이 나왔다.
// 분명 배운것들인데도 이게 맞던가? 이렇게 쓰는거였나? 싶은 것들이 너무 많아서
// 지금은 문법위주로 연습하고 있다.

// 특히 if중첩을 2연속했을때 의도는 완벽한데 중괄호때문에 엄청 해갈린다.
// 아마도 컴파일러를 쓰면 탭키를 이용해 중괄호가 해깔리지 않게 간격을 만들어줘서 해깔리는게 덜 할 것 같은데...
// 지금은 당장 코드를 사용해서 빌드를 해야되는 상황은 아니니까 그냥 메모장이나 AI앱 자체에서 직접 타이핑 하고있는데
// 그래도 익숙하지 않아도 계속 컴파일러로 코딩해야 컴파일러에 익숙해질테니까 그냥 컴파일러를 써야되나..? 싶기도하다
// 아무튼 당장의 목표는 if 30중첩을 문법실수 없이 한번에 작성할 수 있는 것과 변수명이나 내용은 대충 정했다는 의미로 ... 으로 대체한다음
// 그냥 모든 코드를 int ...; char ...; printf(...) if(...){printf(...);}else if{...}else{...}
// 위와 같은식으로 내용은 비워두고 문법만 맞춰보는 연습을 더 해볼 예정.
// 2025. 12. 17 ~ 2025. 12. 19 기록

// 그간 좀 귀찮아서 아무것도 안했다.
// 사실 아무것도 안하지는 않았고 그냥 배웠던 코드들만 대충 써서 문법을 작성함에 있어 실수가 안생기게끔 연습만 했다.
// 그럼에도 아직까지 세미콜론을 깜빡하고 큰따옴표를 빼먹는다.
// gpt는 개발자들이라면 누구나 하는 실수라고는 하지만 그래도 실수빈도를 줄여보고자 문법연습 위주로만 계속 했고 새로운건 거의 배우지 않았다.

// 그러다가 if중첩문이 계속 나오게되니까 gpt가 switch를 알려줬고 그닥 어렵지 않은 것 같아서 한번 배워봤다.
// 확실히 특정상황에서는 매우 편해보이긴 했으나 그 특정상황이 그렇게 자주 나오진 않을 것 같다는 느낌을 받았다.
// 당장 카페에서 주문을 할때만 하더라도 메뉴이름을 말하며 달라고하지 메뉴의 번호로 주문을 받지는 않으니깐.
// 그래서 우선 내가 만든 기존 코드들을 리팩토링 또는 리라이트용으로 switch를 써먹어보았는데 나름 괜찮았다.

// for문을 조금 더 이해해보려고 노력했다.
// 그 결과 이제 대충은 어떻게 써야할지 감은 잡혔다.
// 그리고 for문에서 정수값을 저장하는방법도 배웠는데 이건 굉장히 유용할 것 같다는 생각을 했다.
// 그러나 문법이 익숙하지가 않아서 다음에 다시 써먹어보려고 할떄는 분명 문법실수가 나올 것 같다는 생각을 한다....

// 코드를 만들고 빌드를 하는과정에서 모든게 순식간에 처리되니까 음.. 조금 자연스럽지가 않다는 생각을 하게되어
// 중간중간 특정분기마다 딜레이를 넣어주면 어떨까? 라는 생각을 했다.
// 그리고 windows라는 헤더에 Sleep을 알게되었는데
// 역시나 Sleep에서 S를 대문자가 아닌 소문자 s로 사용하게되면서 에러가 발생했다.
// gpt는 os함수를 처음쓸때 대부분 하는 실수라고 위로해줬다..ㅠㅠ
// 아무튼 새로운 헤더를 배우는게 아직은 부담이 많이 가지만 Sleep은 사용법이 매우 단순해서 그냥 보자마자 이거구나 하고 99% 이해 해버렸다..
// 당분간은 지금까지 배운것들을 내 것으로 만들기 위해 다시 문법위주로 연습할 예정이다.
// 2025. 12. 26 기록.

// 3~4주간 백준, 프로그래머스에서 입출력, 연산, 조건문, 반복문, 배열 예제들을 풀어보면서
// 진짜 이것저것, 여러가지 학습을 했다... 
// 그런데 백준은 이해가 잘 되지 않았던게 배열문제에서 배열을 사용하지 않아도 정답처리 되길래
// 혹시나해서 다른 예제에서 요구하는 함수를 사용하지 않고 결과값만 도출해내봤는데 정답처리가 되질 않았다..
// 그래서 생각한게 어짜피 프로그램의 목적에 맞는 결과값을 도출해낼 수 있다면 하드코딩을 하던 전혀 엉뚱한 방향으로 코딩을 하던
// 학습단계에서는 크게 신경쓰지 않는게 내 정신건강에 도움이 된다는 걸 느꼈다.
// 물론 정석적인 방법을 냅두고 엉뚱한 과정으로 결과를 도출해낸다는게 웃기긴하지만 오히려 정성적으로 문제만 풀이를 하는 사람들한테는
// 이걸 이렇게도 풀어나갈 수 있겠구나? 하는 깨달음을 주지 않을까 생각했다.
// 그래서 생각해낸건 지금껏 계속 이래 왔지만.. 앞으로도 문제가 요구하는 결과값을 우선보고 내 방식대로 그 결과값을 만들어낸 뒤
// 정석적인 방법이랑 비교하면서 배워나가야겠다고 다짐했다...
// 누누히 이야기하지만 취미로 C언어를 배우는 것이기에 그냥 재밌는 방향으로만 학습할거다!

// 3~4주간 배운 것.
// IDE에서 자꾸 VLA이슈가 발생해 어쩔 수 없이 malloc으로 배열을 만드는 방법을 배웠다.

// 포인터의 개념을 어렴풋 이해했다. 완벽하지 않음..! 틀릴수도 있음!

// 로직을 분류해봤다.
// 기존에는 int main 안에 모든 코드를 넣고 빌드 해봤는데
// view(연출), print(연출)로 각각 분류한 뒤 main 안에서 view와 print를 호출해서 사용 해봤음!

// 함수인자의 대해서 배웠다.
// 다른 사람들의 코드를 보면 main(void) 인자안에 void대신 int x; 니 char* y[]; 적혀있길래
// 대체 인자안에 넣는 것들로 무엇을 할 수 있는지 궁금했었는데
// GPT와 GEMINI를 붙잡고 한참동안 물어봐서 간신히 이해했다.
// 내가 이해하지 못했던 이유는 지금껏 IDE를 통해 컴파일 > 빌드 로 코드를 실행했는데
// 함수인자를 이용하려면 터미널에서 직접 해당 파일을 실행할때 함수인자를 같이 넣어줘야 했던거라
// AI들이 설명을 해줘도 한참동안 이해를 못했었다...
// 훗날 다른 초보자가 함수인자를 왜 넣는지 물어볼때 
// 가장 먼저 설명이 필요한 부분은 함수인자가 무엇인지의 대한 개념이 아니라 
// IDE에서 컴파일 후 빌드하는 것과 EXE파일을 직접 실행하는 것의 차이부터 알려줘야 이해하기가 편할 것 같다.

// 주관적으로 생각하는 나의 학습률은 반복문은 완전초급 > 초중급, 조건문은 완전초급 > 초중급, 배열은 완전왕초급 > 완전초급 정도로 올라간 것 같다.
// 학습단계의 정의 { 아무것도모름 < [완전왕초급, 완전초급 , 초급, 초중급] < 중급 < 고급 < 전문가 <<< 해커 }

// 아마 다음 연습할것들은 함수인자를 자연스럽게 사용할 수 있게하고.. 그리고.. 어.. 그리고 반복문과 조건문은 논리구조를 좀 더 자연스럽게 쓸 수있게하고..
// 포인터의 대해서 포인터가 무엇인지 어렴풋이 아니라 장황하게라도 풀어나갈 수 있을정도로 학습해야하고... 아무튼!!
// 배울게 너무너무 많다아아아....
// 2026. 01. 18 기록.
